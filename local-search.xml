<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第一个CMSIS_OS教程</title>
    <link href="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/"/>
    <url>/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第一个CMSIS-OS教程"><a href="#第一个CMSIS-OS教程" class="headerlink" title="第一个CMSIS_OS教程"></a>第一个CMSIS_OS教程</h1>]]></content>
    
    
    <categories>
      
      <category>cmsis_os使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>stm32</tag>
      
      <tag>cmsis_os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一个freertos工程</title>
    <link href="/2025/12/21/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Efreertos%E7%9A%84cmsis%E5%B7%A5%E7%A8%8B/"/>
    <url>/2025/12/21/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Efreertos%E7%9A%84cmsis%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第一个freertos工程"><a href="#第一个freertos工程" class="headerlink" title="第一个freertos工程"></a>第一个freertos工程</h1><h2 id="一、单片机设计模式"><a href="#一、单片机设计模式" class="headerlink" title="一、单片机设计模式"></a>一、单片机设计模式</h2><p>裸机程序的设计模式可以分为：轮询、前后台、定时器驱动、基于状态机。前面三种方法都无法解决一个问题：假设有A、B两个都很耗时的函数，无法降低它们相互之间的影响。第4种方法可以解决这个问题，但是实践起来有难度。</p><p>假设大家现在有两个任务，数据处理以及消息回复，接下来我们会用不同方法给大家介绍如何去处理</p><h3 id="1-1、裸机程序设计模式"><a href="#1-1、裸机程序设计模式" class="headerlink" title="1.1、裸机程序设计模式"></a>1.1、裸机程序设计模式</h3><h4 id="1-1-1、轮询模式"><a href="#1-1-1、轮询模式" class="headerlink" title="1.1.1、轮询模式"></a>1.1.1、轮询模式</h4><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 经典单片机程序: 轮询</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        数据处理();<br>        消息回复();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在main函数中是一个while循环，里面依次调用2个函数，这两个函数相互之间有影响：如果“数据处理”太花时间，就会导致迟迟无法“消息回复”；如果“消息回复”太花时间，就会导致迟迟无法“数据处理”。</p><p>使用轮询模式编写程序看起来很简单，但是要求while循环里调用到的函数要执行得非常快，在复杂场景里反而增加了编程难度。</p><h4 id="1-1-2、前后台"><a href="#1-1-2、前后台" class="headerlink" title="1.1.2、前后台"></a>1.1.2、前后台</h4><p>所谓的’’前后台’’就是采用中断处理，当我们发现有消息需要回复的时候，我们再去进行回复，其他时候则进行数据处理。示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 前后台程序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 后台程序</span><br>        数据处理();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 前台程序</span><br><span class="hljs-type">void</span> 滴_中断()<br>&#123;<br>    消息回复();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>main函数里while循环里的代码是后台程序，平时都是while循环在运行；</li><li>当接收到信息，电脑发出“滴”的一声，触发了中断。我们暂停数据处理，去执行“滴_中断”进行回复信息；</li></ul><p>在这个场景里，回复信息非常及时：即使正在数据处理也会暂停下来去回复信息。“数据处理”无法影响到“消息回复”。但是，如果“消息回复”太花时间，就会导致 “数据处理”迟迟无法执行。</p><h4 id="1-1-3、定时器驱动"><a href="#1-1-3、定时器驱动" class="headerlink" title="1.1.3、定时器驱动"></a>1.1.3、定时器驱动</h4><p>定时器驱动模式，是前后台模式的一种，可以按照不用的频率执行各种函数。比如需要每2分钟给小孩喂一口饭，需要每5分钟给同事回复信息。那么就可以启动一个定时器，让它每1分钟产生一次中断，让中断函数在合适的时间调用对应函数。示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 前后台程序: 定时器驱动</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 后台程序</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 前台程序: 每1分钟触发一次中断</span><br><span class="hljs-type">void</span> 定时器_中断()<br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    cnt++;<br>    <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        数据处理();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        消息回复();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>main函数中的while循环是空的，程序的运行靠定时器中断来驱使。</li><li>定时器中断每1分钟发生一次，在中断函数里让cnt变量累加（代码第14行）。</li><li>第15行：进行求模运算，如果对2取模为0，就“数据处理”。这相当于每发生2次中断就“数据处理”。</li><li>第19行：进行求模运算，如果对5取模为0，就“消息回复”。这相当于每发生5次中断就“消息回复”。</li></ul><p>这种模式适合调用周期性的函数，并且每一个函数执行的时间不能超过一个定时器周期。如果“数据处理”很花时间，比如长达10分钟，那么就会耽误“消息回复”；反过来也是一样的，如果“消息回复”很花时间也会影响到“数据处理”；这种场景下程序遭遇到了轮询模式的缺点：函数相互之间有影响</p><h4 id="1-1-4、状态机"><a href="#1-1-4、状态机" class="headerlink" title="1.1.4、状态机"></a>1.1.4、状态机</h4><p>当“数据处理”、“消息回复”都需要花很长的时间，无论使用前面的哪种设计模式，都会退化到轮询模式的缺点：函数相互之间有影响。可以使用状态机来解决这个缺点，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 状态机</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        数据处理();<br>        消息回复();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在main函数里，还是使用轮询模式依次调用2个函数。</p><p>关键在于这2个函数的内部实现：使用状态机，每次只执行一个状态的代码，减少每次执行的时间，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> 数据处理(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> state = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">switch</span> (state)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        &#123;<br>            <span class="hljs-comment">/* 数据采集 */</span><br>            <span class="hljs-comment">/* 进入下一个状态 */</span><br>            state++;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        &#123;<br>            <span class="hljs-comment">/* 数据滤波 */</span><br>            <span class="hljs-comment">/* 进入下一个状态 */</span><br>            state++;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        &#123;<br>            <span class="hljs-comment">/* 数据计算 */</span><br>            <span class="hljs-comment">/* 进入下一个状态 */</span><br>            state++;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        &#123;<br>            <span class="hljs-comment">/* 数据上报 */</span><br>            <span class="hljs-comment">/* 恢复到初始状态 */</span><br>            state = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> 消息回复(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> state = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">switch</span> (state)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        &#123;<br>            <span class="hljs-comment">/* 查看信息 */</span><br>            <span class="hljs-comment">/* 进入下一个状态 */</span><br>            state++;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        &#123;<br>            <span class="hljs-comment">/* 打字 */</span><br>            <span class="hljs-comment">/* 进入下一个状态 */</span><br>            state++;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        &#123;<br>            <span class="hljs-comment">/* 发送 */</span><br>            <span class="hljs-comment">/* 恢复到初始状态 */</span><br>            state = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以“数据处理”为例，函数内部拆分为4个状态：数据采集、数据滤波、数据计算、数据上报。每次执行“数据处理”函数时，都只会执行其中的某一状态对应的代码。以前执行一次“数据处理”函数可能需要4秒钟，现在可能只需要1秒钟，就降低了对后面“消息回复”的影响。</p><p>同样的，“消息回复”函数内部也被拆分为3个状态：查看信息、打字、发送。每次执行这个函数时，都只是执行其中一小部分代码，降低了对“喂一口饭”的影响。</p><p>使用状态机模式，可以解决裸机程序的难题：假设有A、B两个都很耗时的函数，怎样降低它们相互之间的影响。但是很多场景里，函数A、B并不容易拆分为多个状态，并且这些状态执行的时间并不好控制。所以这并不是最优的解决方法，需要使用多任务系统</p><h3 id="1-2、多任务系统"><a href="#1-2、多任务系统" class="headerlink" title="1.2、多任务系统"></a>1.2、多任务系统</h3><h4 id="1-2-1-多任务模式"><a href="#1-2-1-多任务模式" class="headerlink" title="1.2.1 多任务模式"></a>1.2.1 多任务模式</h4><p>对于裸机程序，无论使用哪种模式进行精心的设计，在最差的情况下都无法解决这个问题：假设有A、B两个都很耗时的函数，无法降低它们相互之间的影响。使用状态机模式时，如果函数拆分得不好，也会导致这个问题。本质原因是：函数是轮流执行的。假设“喂一口饭”需要t1到t5这5段时间，“回一个信息需要”ta到te这5段时间，轮流执行时：先执行完t1到t5，再执行ta到te，如下图所示：</p><p><img src="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/cmsis%E5%B7%A5%E7%A8%8B/image-20251227015448478.png"></p><p>对于单片机来说，怎么解决这个问题呢？从人的角度来说，CPU是一个眼明手快的人，可以一心多用，可以这样做：</p><ul><li>一遍进行数据处理，一遍进行消息回复</li><li>但是脑子只有一个啊，虽然说“一心多用”，但是谁能同时思考两件事？</li><li>上一秒是进行数据处理，下一秒进行消息回复</li><li>本质是：交叉执行，t1到t5和ta到te交叉执行，如下图所示：</li></ul><p><img src="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/cmsis%E5%B7%A5%E7%A8%8B/image-20251227020255879.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// RTOS程序</span><br>数据处理()<br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        数据处理();<br>    &#125;<br>&#125;<br><br>消息回复()<br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        消息回复();<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建2个任务</span><br>    create_task(数据处理);<br>    create_task(消息回复);<br><br>    <span class="hljs-comment">// 启动调度器</span><br>    start_scheduler();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第21、22行，创建2个任务；</li><li>第25行，启动调度器；</li><li>之后，这2个任务就会交叉执行了；</li></ul><p>基于多任务系统编写程序时，反而更简单了：</p><ol><li>上面第2到8行是“喂饭任务”的代码；</li><li>第10到16行是“回信息任务”的代码，编写它们时甚至都不需要考虑它和其他函数的相互影响。就好像有2个单板：一个只运行“喂饭任务”这个函数、另一个只运行“回信息任务”这个函数。</li></ol><p>多任务系统会依次给这些任务分配时间：你执行一会，我执行一会，如此循环。只要切换的间隔足够短，用户会“感觉这些任务在同时运行”。如下图所示：</p><p><img src="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/cmsis%E5%B7%A5%E7%A8%8B/image-20251227020618107.png"></p><h4 id="1-2-2-互斥操作"><a href="#1-2-2-互斥操作" class="headerlink" title="1.2.2 互斥操作"></a>1.2.2 互斥操作</h4><p>多任务系统中，多个任务可能会“同时”访问某些资源，需要增加保护措施以防止混乱。比如任务A、B都要使用串口，能否使用一个全局变量让它们独占地、互斥地使用串口？示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// RTOS程序</span><br><span class="hljs-type">int</span> g_canuse = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">uart_print</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (g_canuse)<br>    &#123;<br>        g_canuse = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(str);<br>        g_canuse = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br>task_A()<br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        uart_print(<span class="hljs-string">&quot;0123456789\n&quot;</span>);<br>    &#125;<br>&#125;<br><br>task_B()<br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        uart_print(<span class="hljs-string">&quot;abcdefghij&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建2个任务</span><br>    create_task(task_A);<br>    create_task(task_B);<br>    <span class="hljs-comment">// 启动调度器</span><br>    start_scheduler();<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的意图是：task_A打印“0123456789”，task_B打印“abcdefghij”。在task_A或task_B打印的过程中，另一个任务不能打印，以避免数字、字母混杂在一起，比如避免打印这样的字符：“012abc”。</p><p>第6行使用全局变量g_canuse实现互斥打印，它等于1时表示“可以打印”。在进行实际打印之前，先把g_canuse设置为0，目的是防止别的任务也来打印。</p><p>这个程序大部分时间是没问题的，但是只要它运行的时间足够长，就会出现数字、字母混杂的情况。下图把uart_print函数标记为①~④个步骤：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">uart_print</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( g_canuse )     ①<br>    &#123;<br>        g_canuse = <span class="hljs-number">0</span>;  ②<br>        <span class="hljs-built_in">printf</span>(str);   ③<br>        g_canuse = <span class="hljs-number">1</span>;  ④<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果task_A执行完①，进入if语句里面执行②之前被切换为task_B：在这一瞬间，g_canuse还是1。</p><p>task_B执行①时也会成功进入if语句，假设它执行到③，在printf打印完部分字符比如“abc”后又再次被切换为task_A。</p><p>task_A继续从上次被暂停的地方继续执行，即从②那里继续执行，成功打印出“0123456789”。这时在串口上可以看到打印的结果为：“abc0123456789”。</p><p>是不是“①判断”、“②清零”间隔太远了，uart_print函数改进成如下的代码呢</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">uart_print</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span><br>&#123;<br>    g_canuse--;            ① 减一<br>    <span class="hljs-keyword">if</span>( g_canuse == <span class="hljs-number">0</span> )    ② 判断<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(str);     ③ 打印<br>    &#125;<br>    g_canuse++;          ④ 加一<br>&#125;<br></code></pre></td></tr></table></figure><p>即使改进为上述代码，仍然可能产生两个任务同时使用串口的情况。因为“①减一”这个操作会分为3个步骤：a.从内存读取变量的值放入寄存器里，b.修改寄存器的值让它减一，c.把寄存器的值写到内存上的变量上去。</p><p>如果task_A执行完步骤a、b，还没来得及把新值写到内存的变量里，就被切换为task_B：在这一瞬间，g_canuse还是1。</p><p>task_B执行①②时也会成功进入if语句，假设它执行到③，在printf打印完部分字符比如“abc”后又再次被切换为task_A。</p><p>task_A继续从上次被暂停的地方继续执行，即从步骤c那里继续执行，成功打印出“0123456789”。这时在串口上可以看到打印的结果为：“abc0123456789”。</p><p>从上面的例子可以看到，基于多任务系统编写程序时，访问公用的资源的时候要考虑“互斥操作”。任何一种多任务系统都会提供相应的函数。</p><h4 id="1-2-3-同步操作"><a href="#1-2-3-同步操作" class="headerlink" title="1.2.3 同步操作"></a>1.2.3 同步操作</h4><p>如果任务之间有依赖关系，比如任务A执行了某个操作之后，需要任务B进行后续的处理。如果代码如下编写的话，任务B大部分时间做的都是无用功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// RTOS程序</span><br><span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">task_A</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 做某些复杂的事情</span><br>        <span class="hljs-comment">// 完成后把flag设置为1</span><br>        flag = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">task_B</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (flag)<br>        &#123;<br>            <span class="hljs-comment">// 做后续的操作</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建2个任务</span><br>    create_task(task_A);<br>    create_task(task_B);<br>    <span class="hljs-comment">// 启动调度器</span><br>    start_scheduler();<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，在任务A没有设置flag为1之前，任务B的代码都只是去判断flag。而任务A、B的函数是依次轮流运行的，假设系统运行了100秒，其中任务A总共运行了50秒，任务B总共运行了50秒，任务A在努力处理复杂的运算，任务B仅仅是浪费CPU资源。</p><p>如果可以让任务B阻塞，即让任务B不参与调度，那么任务A就可以独占CPU资源加快处理复杂的事情。当任务A处理完事情后，再唤醒任务B。示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// RTOS程序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">task_A</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 做某些复杂的事情</span><br>        <span class="hljs-comment">// 释放信号量,会唤醒任务B;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">task_B</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 等待信号量, 会让任务B阻塞</span><br>        <span class="hljs-comment">// 做后续的操作</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建2个任务</span><br>    create_task(task_A);<br>    create_task(task_B);<br>    <span class="hljs-comment">// 启动调度器</span><br>    start_scheduler();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第15行：任务B运行时，等待信号量，不成功时就会阻塞，不在参与任务调度。</li><li>第7行：任务A处理完复杂的事情后，释放信号量会唤醒任务B。</li><li>第16行：任务B被唤醒后，从这里继续运行。</li></ul><p>在这个过程中，任务A处理复杂事情的时候可以独占CPU资源，加快处理速度。</p><h2 id="二、实验原理图"><a href="#二、实验原理图" class="headerlink" title="二、实验原理图"></a>二、实验原理图</h2><p>在本次实验中，我们将实现一个简单的多线程任务，分别让两个灯按不同频率进行闪烁，接线图如下：、</p><p><img src="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/cmsis%E5%B7%A5%E7%A8%8B/image-20251227021657366.png"></p><h2 id="三、STM32CUBEMX配置"><a href="#三、STM32CUBEMX配置" class="headerlink" title="三、STM32CUBEMX配置"></a>三、STM32CUBEMX配置</h2><h3 id="3-1、基本配置"><a href="#3-1、基本配置" class="headerlink" title="3.1、基本配置"></a>3.1、基本配置</h3><p>我们打开<code>STM32CUBEMX</code>，选择对应的芯片后，我们开始配置</p><p>首先RCC的高速时钟选择外部</p><p><img src="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/cmsis%E5%B7%A5%E7%A8%8B/image-20251229202840713.png"></p><p>另外，本实验使用了FreeRTOS，FreeRTOS的时基使用的是Systick，而STM32CubeMX中默认的HAL库时基也是Systick，为了避免可能的冲突，最好将HAL库的时基换做其它的硬件定时器：</p><p><img src="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/cmsis%E5%B7%A5%E7%A8%8B/image-20251229202913178.png"></p><p>最后去时钟配置界面配置系统时钟频率。直接在HCLK时钟那里输入MCU允许的最高时钟频率。F103的最高频率是72Mhz，所以直接在那里输入72然后按回车：</p><p><img src="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/cmsis%E5%B7%A5%E7%A8%8B/image-20251229202944142.png"></p><h3 id="3-2、GPIO配置"><a href="#3-2、GPIO配置" class="headerlink" title="3.2、GPIO配置"></a>3.2、GPIO配置</h3><p>接着，我们根据原理图配置GPIO，这里我们将PB1与PB2配置成推挽输出，重命名位LED1、LED2：</p><p><img src="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/cmsis%E5%B7%A5%E7%A8%8B/image-20251229203259428.png"></p><h3 id="3-3、Freertos配置"><a href="#3-3、Freertos配置" class="headerlink" title="3.3、Freertos配置"></a>3.3、Freertos配置</h3><p>STM32CubeMX已经将FreeRTOS集成到工具中，并且将RTOS的接口进行了封装CMSIS-RTOS V1&#x2F;V2，相较之于V1版本的CMSIS-RTOS API，V2版本的API的兼容性更高，为了将来的开发和移 植，建议开发者使用V2版本的API：</p><p><img src="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/cmsis%E5%B7%A5%E7%A8%8B/image-20251229203508777.png"></p><p>选择CMSIS V2接口后，还要进一步配置FreeRTOS的参数和功能。</p><h4 id="3-3-1、任务配置"><a href="#3-3-1、任务配置" class="headerlink" title="3.3.1、任务配置"></a>3.3.1、任务配置</h4><p>FreeRTOS的参数包括时基频率、任务堆栈大小、是否使能互斥锁等等，需要开发者根据自己对FreeRTOS的了解以及项目开发的需求，来定制参数。 先如下图进行配置（即保持默认）：</p><p><img src="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/cmsis%E5%B7%A5%E7%A8%8B/image-20251229203704214.png"></p><h4 id="3-3-2、添加任务"><a href="#3-3-2、添加任务" class="headerlink" title="3.3.2、添加任务"></a>3.3.2、添加任务</h4><p>使用STM32CubeMX，可以手工添加任务、队列、信号量、互斥锁、定时器等等。但是本课程不想严重依赖STM32CubeMX，所以不会使用STM32CubeMX来添加这些对象，而是手写代码来使用这些对象。</p><p>使用STM32CubeMX时，有一个默认任务，此任务无法删除，只能修改其名称和函数类型，如下图所示：</p><p><img src="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/cmsis%E5%B7%A5%E7%A8%8B/image-20251229203900715.png"></p><p>接着我们创建工程</p><p>创建的过程可能需要我们下载一些东西，点击确定即可</p><h2 id="四、第一个多线程任务"><a href="#四、第一个多线程任务" class="headerlink" title="四、第一个多线程任务"></a>四、第一个多线程任务</h2><p>双击打开freertos.c文件，找到StartDefaultTask函数里的循环。我们编写的代码，需要位于“USER CODE BEGIN xxx”和“USER CODE END xxx”之间，否则以后再次使用STM32CubeMX配置工程时，不在这些位置的用户代码会被删除。</p><p>如下图加入代码：</p><p><img src="/2025/12/22/%E7%AC%AC%E4%B8%80%E4%B8%AACMSIS-OS%E6%95%99%E7%A8%8B/cmsis%E5%B7%A5%E7%A8%8B/image-20251229204452883.png"></p><p>接着烧录到开发板中，我们的LED就会每隔500ms翻转一次。</p><p><strong>版权声明</strong></p><p>本文基于 <a href="https://rtos.100ask.net/">百问网 RTOS 学习文档</a> 编写。</p><ul><li>原文档采用 <strong>GPL v3</strong> 许可证和 <strong>CC BY-NC-SA 4.0</strong> 许可协议。</li><li>本文在遵循上述协议的基础上进行修改和创作。</li><li>转载请注明原始出处：<a href="https://rtos.100ask.net/">rtos.100ask.net</a></li></ul><p>本文仅用于学习交流，禁止用于商业用途。</p>]]></content>
    
    
    <categories>
      
      <category>freertos基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>stm32</tag>
      
      <tag>freertos</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
